---
layout: post
title:  "Cosmos-SDK app anatomy"
author: violetstair
categories: [ CosmosSDK ]
tags: [Golang, Programming]
image: assets/images/cosmos-sdk.png
description: "COSMOS SDK Application 해부"
featured: false
hidden: true
---


## Node Client

데몬, 또는 [Full-Node Client](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md)는 SDK 기반 블록체인의 핵심 프로세스입니다.
네트워크 참가자는 프로세스를 실행하여 state-machine을 초기화 하고, 다른 전체 노드와 연결, 새 블록이 들어올 때 state-machine을 업데이트 합니다.

```text
                ^  +-------------------------------+  ^
                |  |                               |  |
                |  |  State-machine = Application  |  |
                |  |                               |  |   Cosmos SDK 구현부
                |  |            ^      +           |  |
                |  +----------- | ABCI | ----------+  v
                |  |            +      v           |  ^
                |  |                               |  |
Blockchain Node |  |           Consensus           |  |
                |  |                               |  |
                |  +-------------------------------+  |   텐더민트 코어
                |  |                               |  |
                |  |           Networking          |  |
                |  |                               |  |
                v  +-------------------------------+  v
```

블록체인 노드 데몬은 `./cmd/appd/`에 있는 [`main.go`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md#main-function)를 빌드한 바이너리로 '-d' 일반적으로 접두사를 붙인다. (예: `app`의 경우 `appd`, `gaia`의 경우 `gaiad`)
빌드와 관련된 작업은 [Makefile](#dependencies-and-makefile)를 이용해 진행합니다.
노드를 빌드한 후 [`start` 명령어](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md#start-command)를 통해 실행할 수 있습니다.

이 명령어는 다음과 같은 세 가지 기능을 실행합니다.
This command function primarily does three things:

1. [`app.go`](#core-application-file)에 정의된 state-machine의 인스턴스를 생성합니다.
2. `~/.appd/data` 디렉토리에 저장된 `db`에서 추출한 최신 상태로 state-machine을 초기화 합니다. 이 시점에 state-machine의 높이는 `appBlockHeight` 입니다
3. 새 Tendermint 인스턴스를 만들고 시작합니다. 무엇보다도 노드는 피어와 handshake를 수행합니다. 최신 `blockHeight`를 가져오고 로컬 `appBlockHeight`보다 크면 높이를 동기화 할 블록을 재생합니다. `appBlockHeight`가 0이면 노드가 genesis에서 시작되고 Tendermint는 ABCI를 통해 `app`에 `InitChain` 메시지를 전송하여 [`InitChainer`](#initchainer)를 트리거 합니다.

## Core Application File

일반적으로 state-machine의 핵심을 `app.go` 파일에 정의되어 있습니다.
주로 **애플리케이션 타입 정의**와 이를 **생성하고 초기화 하는** 함수가 포함되어 있습니다.

### Type Definition of the Application

첫 번째로 `app.go`에 정의 된 것은 애플리케이션의 `type` 입니다.
일반적으로 다음과 같은 부분으로 구성됩니다.

**[`baseapp`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md) 참조**

`app.go`에 정의 된 커스텀 애플리케이션은 `baseapp`의 확장입니다.
트랜잭션이 Tendermint에 의해 애플리케이션에 전달되면 `app`은 `baseapp`의 메소드를 사용하여 적절한 모듈로 라우팅합니다.
`baseapp`은 모든 [ABCI methods](https://tendermint.com/docs/spec/abci/abci.html#overview)와 [routing logic](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#routing)을 포함하여 애플리케이션에 대한 대부분의 핵심 로직을 구현합니다.

**`store key`의 목록**

전체 상태를 포함하는 [store](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/store.md)는 Cosmos SDK에서 [`multistore`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/store.md#multistore)(store의 store와 같은)로 구현됩니다.
각 모듈은 multiple stores의 하나 또는 여러 store를 사용하여 상태의 일부를 유지합니다.
이러한 store는 `app` 유형으로 선언 된 특정 키를 사용하여 액세스 할 수 있습니다.
이러한 키는 `keeper`와 함께 Cosmos SDK의 [object-capabilities model](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/ocap.md)의 핵심입니다.

**`keeper` 모듈의 목록**

각 모듈은 그 모듈의 저장소에 대한 읽기 및 쓰기를 처리하는 `keeper`라는 추상화를 정의합니다.
한 모듈의 [`keeper`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/keeper.md) 메소드는 다른 모듈에서 호출할 수 있습니다. (권한이 있는 경우)
애플리케이션 type에 선언되면 다른 모듈에게 인터페이스로 전달되며, 승인된 다른 모듈은 인터페이스를 통해 store에 접근할 수 있게 됩니다.

**[`codec`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/encoding.md) 참조**

애플리케이션은 `[]bytes`로만 저장되기 때문에 `codec`을 통해 데이터 구조를 serialize 하거나 deserialize를 합니다.
`codec`은 결정론적(deterministic: 항상 입력 값이 같으면, 출력 값도 같아야 한다) 이어야 하며, 기본 코덱은 [amino](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/encoding.md)를 사용한다.

**[module manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#manager) 참조**

모듈 관리자는 애플리케이션의 모듈을 포함하는 객체입니다.
[`routes`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#routing), [query routes](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#query-routing) 등록 또는 [`InitChainer`](#initchainer), [`BeginBlocker`과 `EndBlocker`](#beginblocker-and-endblocker) 같은 다양한 기능에 대한 모듈간 실행 순서 설정과 같은 이러한 모듈과 관련된 작업을 용이하게 합니다.

애플리케이션 type의 정의에 대한 예제는 [`gaia`](https://github.com/cosmos/gaia)에서 확인할 수 있습니다.

[app.go](https://github.com/cosmos/gaia/blob/5bc422e6868d04747e50b467e8eeb31ae2fe98a3/app/app.go#L87-L115)

### Constructor Function

이 함수는 위 섹션에서 정의된 새 애플리케이션을 구성합니다.
애플리케이션 데몬 명령어 [`start` command](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md#start-command)를 사용하려면 `AppCreator` 서명을 충족해야 합니다.

[constructors.go](https://github.com/cosmos/cosmos-sdk/blob/7d7821b9af132b0f6131640195326aa02b6751db/server/constructors.go#L20)

이 기능이 수행하는 주요 작업은 다음과 같습니다:

- 새로운 [`codec`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/encoding.md)을 인스턴스화하고 [basic manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#basicmanager)를 사용하여 각 애플리케이션 모듈의 `코덱`을 초기화합니다.
- `baseapp` 인스턴스, 코덱 및 모든 적절한 store key에 대한 참조를 사용하여 새 애플리케이션을 인스턴스화합니다.
- 각 애플리케이션 모듈의 `NewKeeper` 함수를 사용하여 애플리케이션의 `type`에 정의 된 모든 [`keeper`](#keeper)를 인스턴스화합니다. 한 모듈의 `NewKeeper`가 다른 모듈의 `keeper`들에 대한 참조를 요구할 수 있으므로 `keeper`는 올바른 순서로 인스턴스화되어야합니다.
- 각 애플리케이션 모듈의 [`AppModule`](#application-module-interface)개체를 사용하여 애플리케이션의 [module manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#manager)를 인스턴스화합니다.
- 모듈 관리자를 사용하여 애플리케이션의 [`routes`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#routing) 및 [query routes](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#query-routing)를 초기화합니다. 트랜잭션이 ABCI를 통해 Tendermint에 의해 애플리케이션에 전달되면 여기에 정의 된 경로를 사용하여 해당 모듈의 [`handler`](#handler)로 라우팅됩니다. 마찬가지로 애플리케이션이 쿼리를 수신하면 여기에 정의 된 쿼리 경로를 사용하여 해당 모듈의 [`querier`](#querier)로 라우팅됩니다.
- 모듈 관리자로 [application's modules' invariants](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/invariants.md)을 등록합니다. invariants은 각 블록의 끝에서 평가되는 변수 (예 : 토큰의 총 공급량)입니다. invariants을 확인하는 프로세스는 [`InvariantsRegistry`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/invariants.md#invariant-registry)라는 특수 모듈을 통해 수행됩니다. invariants의 값은 모듈에 정의 된 예측 값과 같아야합니다. 값이 예측 된 값과 다르면 invariants 레지스트리에 정의 된 트구한 로직이 트리거됩니다 (일반적으로 체인이 중지됨). 이것은 중요한 버그가 눈에 띄지 않고 오래 지속되 수정하기 어렵게 하는 효과를 생성하지 않도록하는 데 유용합니다.
- 모듈 매니저를 이용하여 [application's modules](#application-module-interface) `InitGenesis`, `BegingBlocker`, `EndBlocker` 함수 각각의 실행 순서를 설정 합니다. 모든 모듈에 이러한 기능을 구현하는 것은 아닙니다.
- 나머지 애플리케이션 매개 변수 설정:
  - [`InitChainer`](#initchainer): 애플리케이션을 처음 시작할 때 초기화하는 데 사용됩니다.
  - [`BeginBlocker`, `EndBlocker`](#beginblocker-and-endlbocker): 모든 블록의 시작과 끝에서 호출됩니다.
  - [`anteHandler`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#antehandler): 수수료 및 서명 확인을 처리하는데 사용됩니다.
- stores 마운트.
- application 실행

이 함수는 앱의 인스턴스만 생성하는 반면 실제 상태는 노드가 다시 시작되면 `~/.appd/data` 폴더에서 가져오거나 노드가 처음 시작된 경우 genesis 파일에서 생성됩니다.

애플리케이션 constructor 예제는 [`gaia`](https://github.com/cosmos/gaia)에서 참조할 수 있습니다.

[app.go](https://github.com/cosmos/gaia/blob/f41a660cdd5bea173139965ade55bd25d1ee3429/app/app.go#L110-L222)

### InitChainer

`InitChainer`는 genesis 파일에서 어플리케이션의 상태(예 : 초기 계정의 토큰 보유량 등)를 초기화 하는 기능입니다.
애플리케이션이 Tendermint engine으로부터 `InitChain` 메시지를 수신할 때 호출되며, 노드가 `appBlockHeight == 0`(즉 genesis block) 에서 시작될 때 발생합니다.
애플리케이션은 [`SetInitChainer`](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp#BaseApp.SetInitChainer)를 통해 [constructor](#constructor-function)에서 `InitChainer`를 설정해야 합니다.

일반적으로 `InitChainer`는 대부분 각 애플리케이션의 모듈의 [`InitGenesis`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/genesis.md#initgenesis) 함수로 구성됩니다.
이는 모듈 관리자의 `InitGenesis` 함수를 호출하여 수행되며, 차례로 포함된 각 모듈의 `InitGenesis` 함수를 호출합니다.
모듈의 `InitGenesis` 함수가 호출되어야 하는 순서는 [module 관리자](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md)의 `SetOrderInitGenesis` 메소드를 사용하여 모듈 관리자에서 설정해야 합니다.
이것은 [application's constructor](#application-constructor)에서 이루어지며 `SetOrderInitGenesis`는 `SetInitChainer`보다 먼저 호출되어야 합니다.

`InitChainer`에 대한 예제는[`gaia`](https://github.com/cosmos/gaia)에서 확인할 수 있습니다:

[app.go](https://github.com/cosmos/gaia/blob/f41a660cdd5bea173139965ade55bd25d1ee3429/app/app.go#L235-L239)

### BeginBlocker and EndBlocker

SDK는 개발자에게 애플리케이션의 일부로 코드의 자동 실행을 구현할 수있는 가능성을 제공합니다.
이는 `BeginBlocker`와 `EndBlocker`라는 두 가지 함수를 통해 구현됩니다.
애플리케이션이 텐더 민트 엔진으로부터 `BeginBlock`및 `EndBlock`메시지를 각각 수신 할 때 호출되며, 이는 각 블록의 시작과 끝에서 발생합니다.
애플리케이션은 [`SetBeginBlocker`](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp#BaseApp.SetBeginBlocker)와 [`SetEndBlocker`](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp#BaseApp.SetEndBlocker) 메소드를 통해 [constructor](#constructor-function)에서 `BeginBlocker` 및 `EndBlocker`를 설정해야합니다.
일반적으로 `BeginBlocker`와 `EndBlocker` 함수는 대부분 각 애플리케이션 모듈의 [`BeginBlock` and `EndBlock`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/beginblock-endblock.md) 함수로 구성됩니다. 이는 모듈 관리자의 `BeginBlock`과 `EndBlock` 함수를 호출하여 수행되며, 차례로 포함 된 각 모듈의 `BeginBLock`과 `EndBlock` 함수를 호출합니다.
모듈의 `BegingBlock`과 `EndBlock` 함수가 호출되어야하는 순서는 각각 `SetOrderBeginBlock`, `SetOrderEndBlock` 메서드를 사용하여 모듈 관리자에서 설정해야합니다.
이는 [application's constructor](#application-constructor)의 [module manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md)를 통해 이루어지며, `SetBeginBlocker` 및 `SetEndBlocker` 함수보다 먼저 `SetOrderBeginBlock`과 `SetOrderEndBlock` 메서드를 호출해야합니다.
참고로 애플리케이션 별 블록체인은 결정적이라는 것을 기억하는 것이 중요합니다.
개발자는 `BeginBlocker` 또는`EndBlocker`에 non-determinism을 도입하지 않도록주의해야하며, [gas](./04-gas-fees.md)는 `BeginBlocker` 및 `EndBlocker` 실행 비용을 제한하지 않으므로 계산 비용이 너무 많이 들지 않도록주의해야합니다.

[`gaia`](https://github.com/cosmos/gaia)에서 `BeginBlocker`와 `EndBlocker`의 예제를 참조할 수 있습니다.

[app.go](https://github.com/cosmos/gaia/blob/f41a660cdd5bea173139965ade55bd25d1ee3429/app/app.go#L224-L232)

### Register Codec

`MakeCodec` 함수는 `app.go` 파일의 마지막있는 중요한 함수입니다.
이 함수의 목표는 [codec `cdc`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/encoding.md)(예 : amino)를 인스턴스화하여 `RegisterCodec` 함수를 사용하여 SDK 및 각 애플리케이션 모듈의 코덱을 초기화하는 것입니다.
애플리케이션의 모듈을 등록하기 위해 `MakeCodec` 함수는 `ModuleBasics`에서 `RegisterCodec`를 호출합니다.
`ModuleBasics`는 애플리케이션의 모든 모듈을 나열하는 [basic manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#basicmanager)입니다.
`init()` 함수에서 인스턴스화되며 애플리케이션 모듈(예 : 코덱)의 비종속 요소를 쉽게 등록하는 역할 만합니다.
basic module manager에 대한 자세한 설명은 [이곳](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#basicmanager)에서 확인할 수 있습니다.

[`gaia`](https://github.com/cosmos/gaia)에서 `MakeCodec`에 대한 예제를 참조할 수 있습니다.

[app.go](https://github.com/cosmos/gaia/blob/f41a660cdd5bea173139965ade55bd25d1ee3429/app/app.go#L64-L70)

## Modules

[Modules](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/intro.md)은 SDK 애플리케이션의 핵심입니다. 모듈들은 state-machine안에 있는 state-machine이라고 볼 수 있습니다.
트랜젝션이 ABCI를 통해 Tendermint engine에서 애플리케이션으로 전달되면 [`baseapp`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md)에 의해 처리를 위해 적절한 모듈로 라우팅 됩니다.
이 패러다임을 통해 개발자는 필요한 대부분의 모듈이 이미 존재하기 때문에 복잡한 state-machine을 쉽게 구축할 수 있는 것 입니다.
개발자의 경우 SDK 애플리케이션 빌드와 관련된 대부분의 작업은 개발자가 하게되는 작업은 새로운 모듈을 빌드하고 기존에 존재하는 모듈과 통합하여 하나의 일관된 애플리케이션을 만드는 것입니다.
애플리케이션 디렉토리에서 모듈은 `x/` 디렉토리에 저장하게 됩니다.

### Application Module Interface

모듈은 Cosmos SDK에 정의된 [interfaces](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#application-module-interfaces), [`AppModuleBasic`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#appmodulebasic), [`AppModule`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#appmodule)를 구현해야 합니다.
`interface`는 `codec`과 같은 모듈의 기본 비 종속 요소를 구현하는 반면, `AppModule`과 `AppModuleBasic`는 모듈 메서드(다른 모듈의 `keepr`에 대한 참조가 필요한 메서드 포함)의 대부분을 처리하며, `./module.go`라는 파일에 정의되어 있습니다.
`AppModule`은 모듈을 일관된 애플리케이션으로 구성하는 데 도움이되는 유용한 메서드 모음을 모듈에 제공합니다.
이러한 메소드는 애플리케이션의 모듈 모음을 관리하는 [`module manager`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md#manager)에서 호출됩니다.

### Message Types

[`Message`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/messages-and-queries.md#messages)는 [`Message`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/messages-and-queries.md#messages) 인터페이스를 구현하는 각 모듈에서 정의하는 객체입니다.
각 [`transaction`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/transactions.md)에는 하나 또는 여러 개의 `messages`가 포함됩니다.
노드에서 유효한 트랜잭션 블록을 수신하면 Tendermint는 [`DeliverTx`](https://tendermint.com/docs/app-dev/abci-spec.html#delivertx)를 통해 각 트랜잭션을 애플리케이션에 중계합니다.
그런다음 애플리케이션은 다음과 같이 트랜젝션을 처리합니다.

1. 트랜잭션을 수신하면 애플리케이션은 먼저 수신한 `[]bytes`를 unmarshall 합니다.
2. 그런 다음 거래에 포함 된 메시지를 추출하기 전에 [수수료 결제 및 서명](#gas-fees.md#antehandler)과 같은 거래에 대한 몇 가지 사항을 확인합니다.
3. `message`의 `Type()` 메소드를 사용하여 `baseapp`은 처리를 위해 해당 모듈의 [`handler`](#handler)로 라우팅 할 수 있습니다.
4. 메시지가 성공적으로 처리되면 상태가 업데이트됩니다.

트랜잭션 라이프 사이클에 대한 자세한 내용은 다음 튜토리얼에서 확인할 수 있습니다.

모듈 개발자는 자신의 모듈을 빌드 할 때 사용자 지정 메시지 유형을 만듭니다. 일반적인 관행은 메시지의 유형 선언 앞에 `Msg`를 붙이는 것입니다.
예를 들어 메시지 유형 `MsgSend`를 사용하면 사용자가 토큰을 전송할 수 있습니다.

[msgs.go](https://github.com/cosmos/cosmos-sdk/blob/7d7821b9af132b0f6131640195326aa02b6751db/x/bank/internal/types/msgs.go#L10-L15)

이는 `bank`모듈의 `handler`에 의해 처리되며, 궁극적으로 상태를 업데이트하기 위해 `auth`모듈의 `keeper`를 호출합니다.

### Handler

[`handler`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/handler.md)는 `baseapp`에 의해 라우팅된 후 `message`를 처리하는 모듈의 일부입니다.
모듈의 `handler` 함수는 트랜젝션이 `DeliverTx` ABCI 메시지에 의해 Tendermint에서 중계된 경우에만 실행됩니다.
트랜잭션이 `CheckTx`에 의해 중계되는 경우 stateless 검사 및 수수료 관련 stateful 검사 만 수행됩니다.
`DeliverTx`와 `CheckTx`의 차이점과 상태 stateful 검사와 stateless 저장 검사의 차이점을 더 잘 이해하려면 다음 튜토리얼을 확인하세요.

모듈의 `handler`는 일반적으로 `handler.go`라는 파일에 정의되며 다음으로 구성됩니다.

**switch function**
`NewHandler`를 사용하여 메시지를 적절한 `handler` 함수로 라우팅합니다.
이 함수는 `handler` 함수를 반환하고 [`AppModule`](#application-module-interface)에 등록되어 애플리케이션의 모듈 관리자에서 [application's router](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#routing)를 초기화하는 데 사용됩니다.
[nameservice tutorial](https://github.com/cosmos/sdk-tutorials/tree/master/nameservice)은 이러한 switch에 대한 예제 입니다.

[handler.go](https://github.com/cosmos/sdk-tutorials/blob/master/nameservice/x/nameservice/handler.go#L12-L26)

**모듈에서 정의한 각 메시지 유형에 대한 하나의 핸들러 함수**
개발자는 이러한 함수에 메시지 처리 로직을 작성합니다.
여기에는 일반적으로 메시지가 유효한지 확인하기 위해 stateful 검사를 수행하고 [`keeper`](#keeper)의 메서드를 호출하여 상태를 업데이트하는 작업이 포함됩니다.

handler 함수는 `sdk.Result` type의 결과를 반환하여 메시지가 성공적으로 처리 되었는지를 애플리케이션에 알린다.

[result.go](https://github.com/cosmos/cosmos-sdk/blob/7d7821b9af132b0f6131640195326aa02b6751db/types/result.go#L15-L40)

### Querier

[`Queriers`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/querier.md)는 `handler`가 거래를 처리하는 것과는 반대로 사용자 쿼리에 대한 정보를 제공한다는 점을 제외하고 매우 유사합니다.
[query](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/messages-and-queries.md#queries)는 `queryRoute` 및 일부 `data`를 제공하는 최종 사용자가 [interface](#interfaces)에서 시작합니다.
query는 `queryRoute`를 사용하는 `baseapp`의 `handleQueryCustom` 메소드에 의한 올바른 애플리케이션의 `querier`로 라우팅 됩니다.

[abci.go](https://github.com/cosmos/cosmos-sdk/blob/7d7821b9af132b0f6131640195326aa02b6751db/baseapp/abci.go#L395-L453)

모듈의 `Querier`는 `querier.go`라는 파일에 정의되며 다음으로 구성됩니다.

**switch function**
`NewQuerier`를 사용하여 쿼리를 적절한 `querier`함수로 라우팅합니다.
이 함수는 `querier` 함수를 반환하며 [`AppModule`](#application-module-interface)에 등록되어 애플리케이션의 모듈 관리자에서 [application's query router](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#query-routing)를 초기화하는 데 사용됩니다.
switch에 대한 예제를 [nameservice tutorial](https://github.com/cosmos/sdk-tutorials/tree/master/nameservice)에서 확인할 수 있습니다.:

[querier.go](https://github.com/cosmos/sdk-tutorials/blob/86a27321cf89cc637581762e953d0c07f8c78ece/nameservice/x/nameservice/internal/keeper/querier.go#L19-L32)

**쿼리 가능해야하는 모듈에 의해 정의 된 각 데이터 유형에 대해 하나의 쿼리 기 함수**
개발자는 이러한 함수에 query 처리 로직을 작성합니다. 일반적으로 [`keeper`](#keeper)의 메소드를 호출하여 상태를 query하고 이를 JSON으로 marshalling 하는것이 포함됩니다.

### Keeper

[`Keepers`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/keeper.md)는 각 모듈의 store에 문지기같은 역할을 한다.
각 모듈의 store를 읽고 쓰기 위해서는 `keeper` 모듈을 겨쳐야만 한다.
이것은 Cosmos SDK의 [object-capabilities](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/ocap.md) 모델에 의해 보장됩니다. store에 대한 키를 보유한 객체 만 액세스 할 수 있으며 모듈의 `keeper`만이 모듈의 저장소에 대한 키를 보유해야합니다.

일반적으로 `Keepers`는 `keeper.go` 파일에 정의되고, `keeper` type으로 명시된 메소드들을 가지게 됩니다.

`keeper` type은 다음과 같은 속성으로 구성됩니다.:

- multistore에 있는 모듈의 store에 대한 **키**
- **다른 모듈의 `keeper`**에 대한 참조, `keeper`가 다른 모듈의 store에 접근을 필요로하는 경우에만(읽거나 쓸 수 있음).
- 애플리케이션의 **codec**에 대한 참조, `keepr`는 구조체를 저장하기 전에 marshal 하거나, store가 값으로 `[]bytes`만 허용하기 때문에 이를 검색 할 때 unmarshal 해야합니다.

type 정의와 함께 `keeper.go` 파일의 다음으로 중요한 구성 요소는 `keeper`의 contrructor 함수 `NewKeeper`입니다.
이 함수는 `codec`을 사용하여 위에 정의된 type의 새로운 `keeper`를 인스턴스화 하고 `key`를 저장하며 잠재적으로 다른 모듈의 `keeper`를 매개변수로 참조합니다.
`NewKeeper` 함수는 [application's constructor](#constructor-function)에서 호출됩니다.
나머지 파일은 주로 getter와 setter와 같은 `keeper`의 메소드를 정의합니다.

### Command-Line and REST Interfaces

각 모듈은 [애플리케이션 인터페이스](#application-interfaces)를 통해 최종 사용자에게 노출 될 CLI command 및 REST path를 정의합니다.
이를 통해 최종 사용자는 모듈에 정의된 유형의 메시지를 만들거나 모듈에서 관리하는 상태의 하위 집합을 쿼리 할 수 있습니다.

#### CLI

일반적으로 [모듈 관련 command](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-interfaces.md#cli)는 각 모듈별로 `client/cli`라는 폴더에 정의 되어있습니다.
CLI는 각각 `client/cli/tx.go` 와 `client/cli/query.go`에 정의된 두 파일에 트랜젝션과 쿼리 명령어를 포함합니다.
두 명령어는 [Cobra Library](https://github.com/spf13/cobra)위에 빌드 됩니다.

- 트랜젝션 명령을 사용하면 사용자가 새로운 트랜잭션을 발생시키며, 업데이트된 상태는 블록에 포함됩니다. 모듈에 정의된 각 [message type](#message-types)에 대해 하나의 명령을 작성해야 합니다. 이 명령은 최종 사용자가 제공한 매개변수를 사용하여 메시지의 생성자를 호출하고 이를 트랜젝션으로 매핑합니다. SDK는 서명 및 기타 트랜젝션 메타데이터를 추가로 처리합니다.
- 쿼리를 통해 사용자는 모듈에서 정의한 상태의 하위 집합을 쿼리할 수 있습니다. 쿼리 명령은 [application's query router](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#query-routing)에 쿼리를 전달하고, `queryRoute` 매개변수를 통해 쿼리를 적절한 [querier](#querier)로 라우팅 합니다.

#### REST

[module's REST interface](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-interfaces.md#rest)를 통해 사용자는 트랜잭션을 생성하고 애플리케이션의 [light client daemon](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md#lcd)(LCD)에 대한 REST 호출을 통해 상태를 쿼리할 수 있습니다. REST 경로는 `client/rest/rest.go` 파일에 정의되며, 다음으로 구성됩니다.

- 파일에 정의된 각 경로를 등록하는 `RegisterRoutes` 함수, 이 함수는 애플리케이션 내에서 사용되는 각 모듈에 대해 [main application's interface](#application-interfaces)에서 호출됩니다. SDK에서 사용하는 라우터는 [Gorilla's mux](https://github.com/gorilla/mux)입니다.
- 노출해야하는 각 쿼리 또는 트랜젝션 생성 기능에 대한 사용자 지정 request type 정의. 이러한 사용자 request type은 Cosmos SDK의 기본 `request` 유형을 기반으로 합니다.
  - [rest.go](https://github.com/cosmos/cosmos-sdk/blob/7d7821b9af132b0f6131640195326aa02b6751db/types/rest/rest.go#L47-L60)
- 주어진 모듈로 라우팅할 수 있는 각 요청에 대한 하나의 handler 함수. 이러한 기능은 요청을 처리하는데 필요한 핵심 로직을 구현합니다.

## Application Interface

[Interfaces](https://github.com/cosmos/cosmos-sdk/blob/master/docs/interfaces/interfaces-intro.md)는 최종 사용자가 전체 노드 클라이언트와 상호작용 할 수 있도록 합니다.
이것은 풀 노드에서 데이터를 쿼리하거나 풀 노드에 의해 중계되고 결국 블록에 포함될 새로운 트랜잭션을 생성 및 전송하는 것을 의미합니다.

메인 인터페이스는 [Command-Line Interface](https://github.com/cosmos/cosmos-sdk/blob/master/docs/interfaces/cli.md) 입니다.
SDK 애플리케이션의 CLI는 애플리케이션에서 사용하는 각 모듈에 정의된 [CLI commands](#cli)를 집계하여 빌드 됩니다.
애플리케이션의 CLI는 일반적으로 `-cli` 접미사 (예: `appcli`)를 가지며 `cmd/appcli/main.go`라는 파일에 정의됩니다. 파일에는 다음이 포함됩니다.

**`main()` 함수**
`appcli` 인터페이스 클라이언트를 빌드하기 위해 실행되는 함수. 이 함수는 각 명령을 준비하고 빌드하기 전에 `rootCmd`에 추가합니다. `appCli`의 루트에서이 함수는 `status`,`keys`, `config`와 같은 일반 명령, 쿼리 명령, tx 명령 및 `rest-server`를 추가합니다.

**Query commands**
쿼리 명령은 `appcli/main.go`에 정의된 `queryCmd` 함수를 호출하여 추가됩니다. 이 함수는 블록 또는 유효성 검사 쿼리와 같은 다른 하위 수준 쿼리 명령 뿐만 아니라 각 애플리케이션의 모듈에 정의된 쿼리 명령이 포함된 Cobra 명령(`main()` 함수에서 `sdk.ModuleClients` 배열로 전달됨)을 변환 합니다. 쿼리 명령은 CLI의 `appcli query [query]` 명령을 사용하여 호출됩니다.

**Transaction commands**
트랜젝션 명령은 `txCmd` 함수를 호출하여 추가됩니다.
`queryCmd`와 마찬가지로 이 함수는 애플리케이션의 각 모듈에 정의된 tx 명령과 트랜잭션 서명 또는 브로드 캐시팅과 같은 하위 수준의 tx 명령을 포함하는 Cobra 명령을 반환합니다.
Tx 명령은 CLI의 `appcli tx [tx]` 명령을 사용하여 호출됩니다.

**`registerRoutes` 함수**
[application's light-client daemon (LCD)](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/node.md#lcd) (i.e. `rest-server`) 초기화 시 `main()` 함수에서 호출됩니다.
`registerRoutes`는 각 애플리케이션 모듈의 `RegisterRoutes` 함수를 호출하며 모듈의 경로를 LCD 라우터에 등록합니다. LCD는 `appcli rest-server` 명령을 실행하여 시작할 수 있습니다.

[nameservice tutorial](https://github.com/cosmos/sdk-tutorials/tree/master/nameservice)에서 애플리케이션의 기본 명령 예를 참조하세요

[main.go](https://github.com/cosmos/sdk-tutorials/blob/86a27321cf89cc637581762e953d0c07f8c78ece/nameservice/cmd/nscli/main.go)

## Dependencies and Makefile

개발자가 종속성 관리 및 프로젝트 구축 방법을 자유롭게 선택할 수 있으므로 이 섹션은 선택 사항입니다.
애플리케이션 전체에 사용되는 각 라이브러리를 올바른 버전으로 가져오도록 하는 버전 관리 프레임워크 중 가장 많이 사용 되는 도구는 [`go.mod`](https://github.com/golang/go/wiki/Modules) 입니다.
[nameservice tutorial](https://github.com/cosmos/sdk-tutorials/tree/master/nameservice)의 예제에서 확인할 수 있습니다.

[go.mod](https://github.com/cosmos/sdk-tutorials/blob/c6754a1e313eb1ed973c5c91dcc606f2fd288811/go.mod#L1-L18)

일반적으로 애플리케이션 빌드는 [Makefile](https://en.wikipedia.org/wiki/Makefile)를 사용합니다.
Makefile은 주로 애플리케이션에 대한 두 개의 진입점 [`appd`](#node-client)와 [`appcli`](#application-interface)을 빌드하기전에  `go.mod`가 실행되도록 합니다.
[nameservice tutorial](https://github.com/cosmos/sdk-tutorials/blob/master/nameservice/tutorial/00-intro.md)에서 Makefile의 예제를 확인할 수 있습니다.

[Makefile](https://github.com/cosmos/sdk-tutorials/blob/86a27321cf89cc637581762e953d0c07f8c78ece/nameservice/Makefile)
