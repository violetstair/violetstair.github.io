---
layout: post
title:  "Cosmos-SDK Transaction Lifecycle"
author: violetstair
categories: [ CosmosSDK ]
tags: [Golang, Programming]
image: assets/images/cosmos-sdk.png
description: "Transaction Lifecycle"
featured: false
hidden: true
---

### Transaction Creation

트랜잭션 `Tx`는 사용자가 [command-line](https://github.com/cosmos/cosmos-sdk/blob/master/docs/interfaces/cli.md)에서 다음 형식으로 명령을 입력하여 생성할 수 있으며, `[command]`에 트랜잭션 유형, `[args]`에 인수, `[flags]`에 설정(수수료 같은) 등을 입력합니다.

```bash
[appname] tx [command] [args] [flags]
```

이 명령은 트랜잭션을 자동으로 **생성(create)**하고, 개인키를 사용하여 **서명(sign)**한 다음, 지정된 피어 노드로 **boradcast(전파)**합니다.

트랜잭션 생성을 위한 몇 가지 필수 및 선택 플래그가 있습니다. `--from` 플래그는 거래 트랜잭션을 발생시킬 [account](/cosmos_sdk_2/)을 의미합니다.
예를들어 코인을 전송하는 트랜잭션의 경우 `from`의 주소에서 자금이 인출됩니다.

#### Gas and Fees

사용자가 [수수료](/cosmos_sdk_4/)로 지불할 금액을 표시하는 데 사용할 수 있는 여러 [플래그](https://github.com/cosmos/cosmos-sdk/blob/master/docs/interfaces/cli.md)가 있습니다.

* `--gas`는 계산 리소스를 나타내는 [gas](/cosmos_sdk_4/)의 소비량을 나타냅니다. gas는 트랜잭션에 따라 다르며 실행될 때 까지 정확하게 계산되지 않지만 `--gas`의 값으로 `auto`를 제공하여 추정할 수 있습니다.
* `--gas-adjustment` (선택사항)는 `gas` 사용량 제한으로 인한 거래 취소를 막기위해 사용량을 조정하는데 사용할 수 있습니다. 1.5배를 지정할 경우 사용자는 예상 사용량의 1.5까지 지불할 수 있음을 의미합니다.
* `--gas-prices`는 사용자가 가스 단위당 지불할 금액을 지정하며 하나 또는 여러 토큰 단위힐 수 있습니다. `--gas-prices=0.025uatom, 0.025upho`는 사용자가 가스 단위당 0.025uatom와 0.025upho를 지불할 의사가 있음을 의미합니다.
* `--fees`는 사용자가 지불하고자하는 총 수수료를 지정합니다.

지불된 수수료의 궁국적인 가치는 gas 가격에 가스를 곱한것(`fees = ceil(gas * gasPrices)`)과 같습니다.
따라서 수수료는 가스 가격을 사용하여 계산할 수 있고 그 반대도 가능하므로 사용자는 둘 중 하나만 지정합니다.

나중에 검증인은 주어진 또는 계산된 `gas-prices`를 자신의 `min-gas-prices`와 비교하여 거래를 블록에 포함할지 여부를 결정합니다.
`gas-prices`이 충분히 높지 않다면 `Tx`가 거부되므로 사용자는 더 많은 비용을 지불하도록 유도할 수 있습니다.

#### CLI Example

애플리케이션 `app` 사용자는 CLI에 다음 명령을 입력하여 `senderAddress`에서 `recipientAddress`로 100uatom을 전송하는 트랜잭션을 생성할 수 있습니다.
지불할 gas의 양은 자동을 지정하며, 가스당 0.025uatom의 가격으로 1.5배까지 지불할 수 있습니다.

```bash
appcli tx send <recipientAddress> 1000uatom --from <senderAddress> --gas auto --gas-adjustment 1.5 --gas-prices 0.025uatom
```

#### Other Transaction Creation Methods

CLI은 애플리케이션과 상호작용하는 쉬운 방법이지만 `Tx`는 [REST interface](https://github.com/cosmos/cosmos-sdk/blob/master/docs/interfaces/rest.md) 또는 애플리케이션 개발자가 정의한 다른 entrypoint를 사용하여 만들수 도 있습니다.
사용자 관점에서 상호작용은 사용중인 웹 인터페이스 또는 지갑에 따라 다릅니다.

## Addition to Mempool

`Tx`를 수신하는 각 full-node(Tendermint가 실행되는)는 [ABCI message](https://tendermint.com/docs/spec/abci/abci.html#messages)를 수신합니다.
`CheckTx`를 애플리케이션 계층에 전송하여 유효성을 확인하고 `abci.ResponseCheckTx`를 받습니다.
만약 `Tx`가 검사를 통과하면 노드에 보관됩니다.
[**Mempool**](https://tendermint.com/docs/tendermint-core/mempool.html#mempool)은 각 노드의 고유한 트랜잭션 메모리 풀, 유효하지 않은 `Tx`는 버립니다. 합의에 앞서 노드는 들어오는 트랜잭션을 지속적으로 확인하고 주변 노드들에게 전파합니다.

### Types of Checks

full-node들은 stateless하게 동작하며, `CheckTx` 내에서 `Tx`를 stateful 체크합니다. 계산 낭비를 피하기 위해 가능한 빨리 유효하지 않은 트랜잭션을 식별하고 거부하는것을 목표로 합니다.

***Stateless***
Stateless 검사는 노드가 state에 접근할 필요가 없습니다. light client 또는 offline 노드 같이같이 동작하며 계산 비용이 저렴합니다.
Stateless 검사에서는 주소가 비어있지 않은지, type이 올바른지와 같은 로직이 정의 됩니다.

***Stateful***
Stateful 검사는 커밋된 상태를 기반으로 트랜잭션 및 메시지의 유효성을 검사합니다.
예를 들어 관련 값이 존재하고 거래할 수 있는지, 주소에 충분한 자금이 있는지, 송금인이 거래할 권한이 있거나 올바른 소유권이 있는지 확인하는 것이 포함됩니다.
주어진 순간에 full-node는 일반적으로 다양한 목적을 위해 애플리케이션 내부 상태의 [여러 버전](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#volatile-states)을 갖습니다.
예를 들어 노드는 트랜잭션을 확인하는 동안 상태 변경을 실행하지만 쿼리에 응답하려면 마지막으로 커밋된 상태의 복사본이 필요합니다. 커밋되지 않은 변경으로 상태를 사용하여 응답해서는 안됩니다.

`Tx`를 확인하기 위해 full-node는 _stateless_ 및 _stateful_ 검사를 모두 포함하는 `CheckTx`를 호출한다.
나중에 [`DeliverTx`](#delivertx) 단계에서 추가 유효성 검사가 수행된다. `CheckTx`는 `Tx` 디코딩을 시작으로 여러단계를 거칩니다.

### Decoding

애플리케이션이 기본 합의 엔진(예: Tendermint)에서 `Tx`를 수신하면 어러 [인코딩된](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/encoding.md) `[]byte`형식의 데이터를 처리하려면 unmarshal 되어야 한다.
그런 다음 [`runTx`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#runtx-and-runmsgs) 함수가 `runTxModeCheck` 모드로 실행되도록 호출됩니다. 이 함수는 모든 검사를 실행하지만 상태를 변경하기 전에 종료됩니다.

### ValidateBasic

[`Message`s](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/transactions.md#messages)는 `Tx`에서 추출되어 모듈 개발자가 구현한 각각의 `Msg` 인터페이스의 메소드인 `ValidateBasic`을 실행합니다.
기본 **stateless** 검사를 수행합니다. 예를들어 메시지가 한 주소에서 다른 주소로 코인을 보내는 것 이라면 `ValidateBasic`은 비어있지 않은 주소와 음수가 아닌 코인 금액을 확인할 가능성이 있지만 주소의 계정 잔액과 같은 state에 대한 정보는 필요하지 않습니다.

### AnteHandler

기술적으로는 선택사항 이지만 각 애플리케이션에 대해 정의해야하는 [`AnteHandler`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/basics/gas-fees.md#antehandler)가 실행됩니다.
내부 상태 `checkState`의 딥 카피가 만들어지고 정의된 `AnteHandler`가 트랜잭션 유형에 지정된 검사를 제한적으로 실행합니다.
사본을 사용하면 handler가 마지막으로 커밋된 상태를 수정하지 않고 `Tx`에 대한 stateful 검사를 수행하고 실행이 실패하면 원래 상태로 되돌리게 된다.

예를들어 [`auth`](https://github.com/cosmos/cosmos-sdk/tree/master/x/auth/spec) 모듈 `AnteHandler`는 시퀀스 번호를 확인 및 증분하고, 서명과 계좌 번호, 트랜잭션의 첫 번째 서명자로 부터 수수료를 공재합니다. 모든 상태 변경는 `checkState`를 사용하여 이루어 집니다.

### Gas

`Tx` 실행시 gas 사용량을 추적하는 `GasMeter`를 유지하는 [`Context`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/context.md)가 초기화 됩니다.
사용자가 제공하는 `Tx`의 gas 수량을 `GasWanted`라고 합니다.
`GasConsumed` 실행 중 소모된 gas의 양이 `GasWanted`를 초과하면 실행이 중지되고 캐시된 상태의 복사본에 대한 변경사항은 커밋되지 않습니다.
그렇지 않으면 `CheckTx`는 `GasUsed`를 `GasConsumed`와 동일하게 설정하고 결과에 반환합니다.
gas 및 fee 값을 계산한 후 검증자 노드는 사용자가 지정한 `gas-prices`이 로컬에서 정의한 `min-gas-prices`보다 낮은지 확인합니다.

### Discard or Addition to Mempool

`CheckTx` 중 어느 시점에서 `Tx`가 실패하면 폐기되고 transaction lifecycle은 거기서 끝납니다.
그렇지 않고 `CheckTx`를 성공적으로 통과하면 기본 프로토콜은 이를 peer 노드에 릴레이하고 이를 Mempool에 추가하여 `Tx`가 다음 블록에 포함될 후보가 되도록 합니다.

**mempool**은 모든 full-node에서 볼 수 있는 트랜잭션을 추적하는 목적으로 사용됩니다.
full-node는 replay attacks을 방지하기 위한 첫 번째 방어선으로 마지막으로 확인한 `mempool.cache_size` 트랜잭션의 **mempool cache**를 유지합니다.
이상적으로는 `mempool.cache_size`는 전체 mempool의 모든 트랜잭션을 포함할 수 있을 만큼 충분히 큽니다.
mempoll 캐시가 너무 작아서 모든 트랜잭션을 추적할 수 없는 경우 `ChechTx`는 재생된 트랜잭션을 식별하고 거부합니다.

현재 기존의 예방 조치에는 재생되는 트랜잭션과 동일하지만 유효한 트랜잭션을 구별하기위한 수수료 및 `sequence` (nonce) 카운터가 포함됩니다.
공격자가 `Tx`의 복사본이 많은 노들에 스팸을 시도하면 mempoll 캐시를 유지하는 전체 노드는 모두에게서 `CheckTx`를 실행하는 대신 동일한 복사본을 거부합니다.
공격자가 많은양의 복사한 `Tx`를 노드에 전달하여 스팸을 시도한다면 mempool 캐시를 유지하는 full-node는 모두에게 `CheckTx`를 실행하게 하는 대신 해당 복사본에 대해 거부를 하게 됩니다.
복사본이 `sequence` 번호를 증가시켰다고 하더라도 공격자들은 수수료를 지불해야 하므로 이득을 얻지 못할것 입니다.

검증자 노드는 full-node와 마찬가지로 replay attacks을 방지하기 위해 mempool을 유지하지만 트랜잭션을 블록에 추가하려고 준비할 때 확인되지 않은 트랜잭션 풀로도 사용합니다.
이 단계에서 `Tx`가 모든 검사를 통과했다 하더라도 `CheckTx`는 트랜잭션을 완전히 검증하지 않기 때문에(실제 메시지를 실행하지는 않았으니까) 나중에 유효하지 않은 것으로 판명될 수 도 있습니다.

## Inclusion in a Block

합의는 검증자 노드가 승인된 트랜잭션을 수락하는 **rounds** 단계에서 발생합니다.
각 라운드는 제안자가 가장 최근 트랜잭션 블록을 생성하는 것으로 시작해 합의를 담당하고 투표 권한이 있는 **검증자**라는 특수 노드으로 끝납니다. 블록을 수락하거나 대한 `nil` 블록으로 이동합니다.
Validator 노드는 [Tendermint BFT](https://tendermint.com/docs/spec/consensus/consensus.html#terms)와 같은 압의 알고리즘을 실행하여 압의에 도달하기 위해 애플리케이션에 대한 ABCI 요청을 사용하여 트랜잭션을 확인합니다.

첫 번째 단계는 **블록 제안(block proposal)**입니다.
검증자 중 한명의 제안자는 함의 알고리즘에 의해 선택되어 블록을 생성하고 제안합니다. `Tx`가 포함되려면 제안자의 mempool에 있어야 합니다.

## State Changes

합의의 다음 단계는 트랜잭션을 실행하여 완전히 검증하는 것 입니다.
올바른 제안자로부터 블록 제안을 받은 모든 full-node는 ABCI 함수 [`BeginBlock`](/cosmos_sdk_0/1), rkr xmfoswortusdp eogks `DeliverTx`, [`EndBlock`](/cosmos_sdk_0/1)을 호출하여 트랜잭션을 실행합니다.
각 전체 노드가 모든것을 로컬에서 실행하는 동안 프로세스는 메시지의 상태 전환이 결정적이고 트랜잭션이 블록 제안에 명시적으로 정렬되기 때문에 하나의 명확한 결과를 생성합니다.

```text
        -----------------------
        |Receive Block Proposal|
        -----------------------
                  |
                  v
        -----------------------
        |     BeginBlock      |
        -----------------------
                  |
                  v
        -----------------------
        | DeliverTx(tx0)      |  
        | DeliverTx(tx1)      |
        | DeliverTx(tx2)      |  
        | DeliverTx(tx3)      |  
        |    .                |
        |    .                |
        |    .                |
        -----------------------
                  |
                  v
        -----------------------
        |      EndBlock       |
        -----------------------
                  |
                  v
        -----------------------
        |      Consensus      |
        -----------------------
                  |
                  v
        -----------------------
        |       Commit        |
        -----------------------
```

### DeliverTx

[`baseapp`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md)에 정의된 `DeliverTx` ABCI 함수는 대부분의 상태 전환을 수행합니다.
합의 중 커밋된 순서대로 블록의 각 트랜잭션에 대해 실행됩니다.
내부적으로 `DeliverTx`는 `CheckTx`와 거의 동일하지만 검사 모드가 아닌 전달 모드에서 [`runTx`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#runtx)함수를 호출합니다.
`checkState`를 사용하는 대신 full-node는 `deliverState`를 사용합니다.

* **Decoding:** `DeliverTx`는 ABCI 호출이므로 `Tx`는 인코딩된 `[]byte` 형식으로 수신됩니다. 노드는 먼저 트랜잭션을 unmarshal한 다음 `runTxModelDeliver`에서 `runTx`를 호출합니다. `CheckTx`와 매우 유사하지만 상태 변경을 실행하고 기록 합니다.

* **Checks:** Full-node는 `validateBasicMsgs`와 `AnteHandler`를 다시 호출합니다. 이 두 번째 확인은 Mempool 단계에 추가되는 동안 동일한 트랜잭션을 보지 보지 못 했을 수도 있고 악의적인 제안자가 유효하지 않은 제안을 포함했을 수 있기 때문에 발생합니다. 여기서 한가지 차이점은 `AnteHandler`가 `gas-prices`를 노드의 `min-gas-prices`와 비교하지 않는다는 점ㅇ 입니다. `min-gas-prices` 값은 각 노드의 로컬 값이기 때문에 노드간에 값이 다르면 비결정적 결과가 생성됩니다.

* **Route and Handler:** `CheckTx`가 종료되었지만 `DeliverTx`는 트랜잭션 내에서 각 `Msg`를 완전히실행하기 위해 [`runMsgs`]https://github.com/cosmos/cosmos-sdk/blob/master/docs./co00-baseapp.md#runtx-and-runmsgs)를 계속 실행합니다. 트랜잭션에는 다른 모듈의 메시지가 있을 수 있으므로 `baseapp`은 적절한 handler를 찾을 모듈을 알아야 합니다. 따라서 [module manager](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/module-manager.md)를 통해 `route` 함수를 호출하여 경로 이름을 검색하고 모듈 내에서 [`Handler`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/building-modules/handler.md)를 찾습니다.

* **Handler:** `AnteHandler`에서 한 단계 업그레이드된 `handler`는 `Tx`의 각 메시지를 실행하고 `deliverTxState`에서 상태 전환이 지속되도록 합니다. `Msg`의 모듈 내에 정의되고 모듈 내의 적절한 store에 기록 됩니다.

* **Gas:** `Tx`가 전달되는 동안 `GasMeter`는 gas 사용량을 추적하는데 사용됩니다. 실행이 완료되면 `GasUsed`가 설정되고 `abci.ResponseDeliverTx`에 반환됩니다. `BlockGasMeter` 또는 `GasMeter`가 부족하거나 다른 문제가 발생하여 실행이 중단되면 마지막에 defer function은 적절하게 오류 또는 패닉 상태가 됩니다.

`Tx`가 유효하지 않거나 `GasMeter`가 부족하여 실패한 상태 변경이 있는경우 transaction 처리는 종료되고 모든 상태 변경은 되돌립니다.
블록 제안에서 유효하지 않은 트랜잭션으로 인해 검증자 노드는 블록을 거부하고 대신 `nil` 블록에 투표합니다.
`Tx`가 성공적으로 전달되면 남은 gas가 사용자에게 반환되고 트랜잭션이 검증됩니다.

### Commit

마지막 단계는 노드가 블록 및 상태변경을 커밋하는 단계 입니다.
Validator node는 트랜잭션의 유효성을 검사하기 위해 상태 전환을 실행하는 이전 단계를 수행한 다음 블록에 서명하여 확인 합니다.
validator가 아닌 full-node는 합의에 참여하지 않지만 상태 변경을 수행해야 하는지 여부를 이해하기 위해 투표를 수신합니다.

충분한 validator의 투표를 받으면 전체 노드는 블록체인에 추가할 새 블록을 커밋하고 애플리케이션 계층에서 상태 전환을 마무리합니다.(2/3 + *precommits* 가중 투표권)
상태전환에 대한 merkle proof 역할을 하는 새로운 state root가 생성됩니다.
애플리케이션은 [Baseapp](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md)에서 상속된 [`Commit`](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#commit) ABCI 메서드를 사용합니다.
애플리케이션의 내부 상태에 `deliverState`를 작성하여 모든 상태 전환을 동기화합니다.
상태변경이 커밋되자마자 `checkState`는 가장 최근에 커밋된 상태에서 새로 시작되고 `deliverState`는 일관성을 유지하고 변경 사항을 반영하기 위해 `nil`로 재설정 됩니다.

모든 블록이 동일한 수의 트랜잭션을 갖는것은 아니며 합의가 `nil` 블록 또는 전혀 없는 블록이 될 수 있습니다.
퍼블릭 블록체인 네트워크에서는 validator가 **byzantine**이거나 악의적일 수 있으며, 이로인해 블록체인에서는 `Tx`가 커밋되지 않을 수 있습니다.
가능한 악의적인 행동으로는 `Tx`를 블록에서 제외하여 검열하기로 결정한 제안자 또는 블록에 대해 투표하는 validator가 있습니다,

이시점에서 `Tx`의 transaction lifecycle은 끝났습니다. 노드는 유효성을 확인하고 상태변경을 실행하여 전달하고 변경사항을 커밋 했습니다.
`[]byte` 형태의 `Tx` 자체는 블록에 저장되고 블록체인에 추가됩니다.
